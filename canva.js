!function (t) { var e = {}; function i(r) { if (e[r]) return e[r].exports; var n = e[r] = { i: r, l: !1, exports: {} }; return t[r].call(n.exports, n, n.exports, i), n.l = !0, n.exports } i.m = t, i.c = e, i.d = function (t, e, r) { i.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: r }) }, i.r = function (t) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) }, i.t = function (t, e) { if (1 & e && (t = i(t)), 8 & e) return t; if (4 & e && "object" == typeof t && t && t.__esModule) return t; var r = Object.create(null); if (i.r(r), Object.defineProperty(r, "default", { enumerable: !0, value: t }), 2 & e && "string" != typeof t) for (var n in t) i.d(r, n, function (e) { return t[e] }.bind(null, n)); return r }, i.n = function (t) { var e = t && t.__esModule ? function () { return t.default } : function () { return t }; return i.d(e, "a", e), e }, i.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, i.p = "", i(i.s = 91) }({ 0: function (t, e, i) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var r = i(11); e.CanvaImage = r.CanvaImage; var n = i(3); e.ColorStops = n.ColorStops; var o = i(4); e.ControlName = o.ControlName; var a = i(4); e.ColorPicker = a.ColorPicker, e.Page = a.Page, e.Select = a.Select, e.Textbox = a.Textbox; var s = i(7); e.Group = s.Group; var c = i(5); e.Slider = c.Slider; var h = i(6); e.Button = h.Button; var l = i(14); e.PreviewOverlay = l.PreviewOverlay; var u = i(15); e.ThumbnailId = u.ThumbnailId, e.ThumbnailList = u.ThumbnailList; var p = i(8); e.UnreachableError = p.UnreachableError, e.UnimplementedError = p.UnimplementedError; var d = i(16); e.Message = d.Message; var f = i(9); e.Envelope = f.Envelope, e.Mailbox = f.Mailbox; var m = i(10); e.EventHandler = m.EventHandler; var v = i(17); e.HostBus = v.HostBus; var g = i(18); e.connect = g.connect; var y = i(20); e.CanvaApiClient = y.CanvaApiClient }, 1: function (t, e, i) { "use strict"; i.d(e, "j", function () { return r }), i.d(e, "k", function () { return n }), i.d(e, "l", function () { return o }), i.d(e, "d", function () { return s }), i.d(e, "q", function () { return c }), i.d(e, "r", function () { return h }), i.d(e, "o", function () { return l }), i.d(e, "e", function () { return u }), i.d(e, "g", function () { return p }), i.d(e, "i", function () { return d }), i.d(e, "p", function () { return f }), i.d(e, "f", function () { return m }), i.d(e, "s", function () { return v }), i.d(e, "t", function () { return g }), i.d(e, "c", function () { return y }), i.d(e, "b", function () { return x }), i.d(e, "a", function () { return b }), i.d(e, "m", function () { return _ }), i.d(e, "n", function () { return w }), i.d(e, "h", function () { return M }); const r = (t = "canvas") => { const e = document.getElementById(t); if (!e) throw new Error("Could not find element with id: " + t); return e }, n = (t = r()) => { const e = t.getContext("2d"); if (!e) throw new Error("could not get 2d context"); return e }, o = (t = r()) => { const e = t.getContext("webgl", { preserveDrawingBuffer: !0 }); if (!e) throw new Error("could not get webgl context"); return e }; function a(t, e, i) { const r = t.createShader(e); if (!r) throw new Error("Could not create shader"); if (t.shaderSource(r, i), t.compileShader(r), t.getShaderParameter(r, t.COMPILE_STATUS)) return r; throw console.error(t.getShaderInfoLog(r)), t.deleteShader(r), new Error("could not compile shader " + e) } const s = t => { const e = t.createTexture(); if (!e) throw new Error("Could not create texture"); return t.bindTexture(t.TEXTURE_2D, e), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), e }, c = () => navigator.userAgent.includes("Safari/") && !navigator.userAgent.includes("Chrom"); function h(t, e, i) { const r = function (t, e, i) { let r = null; try { if (!(r = t.createProgram())) throw new Error("Could not create program"); if (t.attachShader(r, e), t.attachShader(r, i), t.linkProgram(r), t.getProgramParameter(r, t.LINK_STATUS)) return r } catch (e) { r && (console.error(t.getProgramInfoLog(r)), t.deleteProgram(r)) } if (r) return r; throw new Error("could not create program") }(t, a(t, t.VERTEX_SHADER, e), a(t, t.FRAGMENT_SHADER, i)); if (!r) throw new Error("could not create program"); return r } function l(t, e, i) { const r = t.getUniformLocation(e, i); if (null == r) throw new Error(`Could not find shader uniform "${i}"`); return r } function u(t) { const e = t.createBuffer(); if (null == e) throw new Error("Could not create buffer"); return e } function p(t) { const e = t.createTexture(); if (null == e) throw new Error("Could not create texture"); return e } function d(t, e, i) { const r = t.getAttribLocation(e, i); if (-1 === r) throw new Error(`Could not find attribute with name "${i}"`); return r } function f(t) { if ("#" === t.charAt(0) && (t = t.substr(1)), t.length < 2 || t.length > 6) throw new Error("invalid color: " + t); const e = t.split(""); let i, r, n; if (2 === t.length) r = i = parseInt(e[0].toString() + e[1].toString(), 16), n = i; else if (3 === t.length) i = parseInt(e[0].toString() + e[0].toString(), 16), r = parseInt(e[1].toString() + e[1].toString(), 16), n = parseInt(e[2].toString() + e[2].toString(), 16); else { if (6 !== t.length) throw new Error("invalid color: " + t); i = parseInt(e[0].toString() + e[1].toString(), 16), r = parseInt(e[2].toString() + e[3].toString(), 16), n = parseInt(e[4].toString() + e[5].toString(), 16) } return [i / 255, r / 255, n / 255] } function m(t, e, i, r) { const [n, o] = [t, e], [a, s] = [t + i, e], [c, h] = [t, e + r], [l, u] = [t + i, e + r]; return new Float32Array([n, o, a, s, c, h, c, h, a, s, l, u]) } function v(t) { const e = t.getError(); let i = "UNKNOWN"; if (0 !== e) { switch (e) { case t.INVALID_ENUM: i = "INVALID_ENUM"; case t.INVALID_VALUE: i = "INVALID_VALUE"; case t.INVALID_OPERATION: i = "INVALID_OPERATION"; case t.INVALID_FRAMEBUFFER_OPERATION: i = "INVALID_FRAMEBUFFER_OPERATION"; case t.OUT_OF_MEMORY: i = "OUT_OF_MEMORY"; case t.CONTEXT_LOST_WEBGL: i = "CONTEXT_LOST_WEBGL" }console.error("gl render error", e, i) } } function g(t) { t.style.width = "100%", t.style.height = "100%"; const e = t.clientWidth, i = t.clientHeight; t.width === e && t.height === i || (t.width = e, t.height = i) } function y(t, e) { if (null == t) throw new Error(e || "Expected value but found " + t); return t } var x, b; !function (t) { t.create = (t, e) => ({ x: t, y: e }) }(x || (x = {})), function (t) { t.viewportToGlCoords = function (t, e) { return { x: e.x / t.width * 2 - 1, y: 1 - e.y / t.height * 2, width: e.width / t.width * 2, height: -e.height / t.height * 2 } }, t.viewportToTexCoords = function (t, e) { return { x: e.x / t.width, y: e.y / t.height, width: e.width / t.width, height: e.height / t.height } } }(b || (b = {})); function _() { const t = { alpha: !0, preserveDrawingBuffer: !1, antialias: !0, precision: "highp" }; return c() ? t : Object.assign({}, t, { premultipliedAlpha: !1 }) } function w(t, e = window.devicePixelRatio || 1) { const { width: i, height: r } = t, n = 76 * e / Math.min(i, r); return { width: i * n, height: r * n } } function M(t, e) { const i = t.width / t.height, r = t.width / t.height; let n = e.width, o = e.height; return i > r ? n = o / i : i < r && (o = n * i), { width: n, height: o } } }, 10: function (t, e, i) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); e.EventHandler = class { constructor() { this.handlers = new Set } addEventListener(t) { this.handlers.add(t) } removeEventListener(t) { this.handlers.delete(t) } emit(...t) { return this.handlers.forEach(e => e(...t)) } } }, 11: function (t, e, i) { "use strict"; var r = this && this.__awaiter || function (t, e, i, r) { return new (i || (i = Promise))(function (n, o) { function a(t) { try { c(r.next(t)) } catch (t) { o(t) } } function s(t) { try { c(r.throw(t)) } catch (t) { o(t) } } function c(t) { var e; t.done ? n(t.value) : (e = t.value, e instanceof i ? e : new i(function (t) { t(e) })).then(a, s) } c((r = r.apply(t, e || [])).next()) }) }; Object.defineProperty(e, "__esModule", { value: !0 }); const n = navigator && navigator.userAgent.match(/chrome/i) && navigator.userAgent.match(/safari/i), o = t => n ? a(t) : s(t), a = t => new Promise((e, i) => { const r = new FileReader; r.onload = function () { if (r && r.result instanceof ArrayBuffer) { const i = s(new Blob([new Uint8Array(r.result)], { type: t.type })); e(i) } else i("unknown error") }, r.onerror = t => i(t), r.readAsArrayBuffer(t) }), s = t => new Promise((e, i) => { const r = new Image; r.crossOrigin = "anonymous"; const n = URL.createObjectURL(t); r.onload = () => { e(r), URL.revokeObjectURL(n) }, r.onerror = () => { console.error("blobToImage", "failed"), i("Could not load image") }, r.src = n }); !function (t) { t.fromCanvas = (t, e, i) => new Promise((r, n) => { (i => { if (null != i) { const { width: n, height: o } = e; r({ blob: i, imageType: t, width: n, height: o }) } else console.error("blob error"), n("Could not create Blob from Canvas") })(((t, e, i) => { const r = t.toDataURL(e, i).split(",")[1], n = atob(r), o = n.length, a = new Uint8Array(o); for (let t = 0; t < o; t++)a[t] = n.charCodeAt(t); return new Blob([a], { type: e || "image/png" }) })(e, t, i)) }), t.fromDataUrl = (t, e) => r(this, void 0, void 0, function* () { const i = function (t) { const e = atob(t.split(",")[1]), i = t.split(",")[0].split(":")[1].split(";")[0], r = new ArrayBuffer(e.length), n = new Uint8Array(r); for (let t = 0; t < e.length; t++)n[t] = e.charCodeAt(t); return new Blob([r], { type: i }) }(e), { width: r, height: n } = yield o(i); return { blob: i, imageType: t, width: r, height: n } }), t.fromUrl = t => r(this, void 0, void 0, function* () { const e = yield fetch(t), i = yield e.blob(), r = i.type, { width: n, height: a } = yield o(i); return { blob: i, imageType: r, width: n, height: a } }), t.toImageElement = t => o(t.blob), t.toDataUrl = t => new Promise((e, i) => { const r = new FileReader; r.onload = t => { r.result && "string" == typeof r.result ? e(r.result) : i("Unexpected FileReader result") }, r.onerror = () => { i("Error loading blob") }, r.readAsDataURL(t.blob) }), t.getSize = t => ({ width: t.width, height: t.height }) }(e.CanvaImage || (e.CanvaImage = {})) }, 12: function (t, e, i) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), function (t) { t.BUTTON = "button", t.COLOR_PICKER = "color_picker", t.COLOR_STOPS = "color_stops", t.PAGE = "control_panel", t.GROUP = "group", t.SELECT = "select", t.SLIDER = "slider", t.TEXTBOX = "textbox", t.THUMBNAIL_LIST = "thumbnail_list" }(e.ControlName || (e.ControlName = {})) }, 13: function (t, e, i) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), function (t) { t.create = t => Object.assign({ type: "select" }, t) }(e.Select || (e.Select = {})) }, 14: function (t, e, i) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), function (t) { let e; t.type = "PREVIEW_OVERLAY", function (t) { t.SUCCESS = "success", t.ERROR = "error", t.INFO = "info" }(e = t.NotificationType || (t.NotificationType = {})), t.create = e => Object.assign({ type: t.type }, e) }(e.PreviewOverlay || (e.PreviewOverlay = {})) }, 15: function (t, e, i) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), function (t) { t.create = t => t }(e.Thumbn…